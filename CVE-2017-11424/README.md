CVE-2017-11424 PoC Without the Public Key
=========================================

When a JWT validator doesn't allow explicit specication of the signature algorithm, the verification method is determined based on the `alg` information contained in the (user-supplied) JWT. Asymmetric signature verification is perfromed with a public key. When changing the asymmetric authentication algorithm to a symmetric one (such as HS256), the public key used for verification will be the one that supposed to have authenticated the message. 

PyJWT uses a file header blacklist to prevent accidentally using public keys for symmetric MAC verification, but the `-----BEGIN RSA PUBLIC KEY-----` marker was missing from this list, thus [CVE-2017-11424](https://github.com/jpadilla/pyjwt/pull/277) was born. Such key files [can be generated](https://blog.ndpar.com/2017/04/17/p1-p8/) from private keys with the following OpenSSL command:

```
openssl rsa -in private.pem -out public.pem -RSAPublicKey_out
```

In most practical JWT scenarios neither the private nor the public keys are known to an attacker, so exploitation in a black-box setting may seem unlikely. However, at least in case of RSA, public keys can be recovered from two message-signature pairs with the method described [here](https://crypto.stackexchange.com/questions/30289/is-it-possible-to-recover-an-rsa-modulus-from-its-signatures).

The code in this directory demonstrates recovery of public keys, and forging valid JWT tokens against a vulnerable version of pyJWT.

Contents
--------

Build a Python 3.8 virtualenv using the provided `requirements.txt`.

### confusing.py

Test code to reproduce JWT signature generation with `gmpy2`.

### test_CVE-2017-11424.py

Test script for the targeted vulnerability to check if a vulnerable version is available in the local environment.

### x_CVE-2017-11424.py

Proof-of-Concept exploit. It takes two RS2048 signed JWT's as cmdline arguments. It generates PEM files from the possible public key parameters (there can be multiple candidates). It automatically creates forged JWT tokens with HS256 signatures, using the PEM files as keys. 

### test_tampered_jwt.py

It checks whether a tampered JWT checks out with pyJWT when using the original public key. 

Example
-------

TODO

Limitations
-----------

* If the target explicitly sets the signature algorithm the attack won't work

Public key guessing:
* The server needs to have its keys in the same format we generate. Implementing other output formats is an exercise for the reader (I suffered enough from ASN.1, and so should you)
* If key files contain additional, unpredictable data, the key can not be reconstructed.
